---
title: '10 практических рекомендаций по безопасности образов Docker.'
date: 2020-01-11
permalink: /posts/2020/01/blog-post-2/
tags:
  - Docker
  - category1
  - category2
---

Эта статья советов и рекомендаций, которые обеспечивают более безопасный и качественный процесс обработки образов Docker.
[Оригинал - part1](https://habr.com/ru/company/otus/blog/480970/)
[Оригинал - part2](https://habr.com/ru/company/otus/blog/482044/)

Предпочитайте минимальные базовые образы
======
Зачастую вы можете начинать проекты с базового образа контейнера Docker, например, с написания Dockerfile с FROM node «по умолчанию». Однако при указании образа node следует учитывать, что полностью установленный дистрибутив Debian Stretch является базовым образом, который используется для его сборки. Если ваш проект не требует каких-либо общих системных библиотек или утилит, то лучше избегать использования полнофункциональной операционной системы (ОС) в качестве базового образа.

Многие популярные контейнеры Docker, представленные на веб-сайте Docker Hub, содержат в себе образы, содержащие много известных уязвимостей. Например, когда вы используете популярный универсальный образ docker pull node вы фактически вводите в свое приложение ОС, которая, как известно, имеет 580 уязвимостей в своих системных библиотеках.
[УЗНАЙТЕ БОЛЬШЕ О БЕЗОПАСНОСТИ ВАШИХ ОБРАЗОВ](https://snyk.io/container-vulnerability-management/)

Наименее привилегированный пользователь
======
Когда Dockerfile не указывает USER, по умолчанию контейнер выполняется с использованием root-пользователя. На практике существует очень мало причин, по которым контейнер должен иметь root-привилегии. Docker по умолчанию запускает контейнеры, используя root-пользователя. Затем когда это пространство имен сопоставляется с root-пользователем в работающем контейнере, из этого следует, что контейнер потенциально имеет root-доступ на хосте Docker. Запуск приложения в контейнере с root-пользователем еще больше расширяет пространство для атаки и обеспечивает легкий путь к повышению привилегий, если само приложение уязвимо для эксплойтов.

Чтобы минимизировать незащищенность, включите создание специально выделенного пользователя и группу в образе Docker для приложения; используйте директиву USER в Dockerfile, чтобы убедиться, что контейнер запускает приложение с наименее привилегированным доступом.

Выделенный пользователь может не существовать в образе; создайте этого пользователя, используя инструкции в Dockerfile.

Ниже приведен полный пример того, как это сделать для универсального образа Ubuntu:

`ROM ubuntu
RUN mkdir /app
RUN groupadd -r lirantal && useradd -r -s /bin/false -g lirantal lirantal
WORKDIR /app
COPY . /app
RUN chown -R lirantal:lirantal /app
USER lirantal
CMD node index.js`

Пример выше:

создает системного пользователя (-r) без пароля, без установки домашнего каталога и без оболочки
добавляет пользователя, которого мы создали, к существующей группе, которую мы создали заранее (используя groupadd)
добавляет последний аргумент к имени пользователя, которого мы хотим создать, в сочетании с группой, которую мы создали

Node.js и образов alpine, они уже включают в себя универсального пользователя, называемого node. Вот пример Node.js, использующий универсального пользователя node:

`FROM node:10-alpine 
RUN mkdir /app
COPY . /app
RUN chown -R node:node /app
USER node
CMD [“node”, “index.js”]`


Подписывайте и проверяйте образы, чтобы избегать MITM атаки
======

Аутентичность образов Docker является проблемой. Мы полагаемся на эти образы, поскольку буквально используем их в качестве контейнера, который запускает наш код в продакшене. Поэтому важно убедиться, что образ, который мы используем, является именно тем, который поставляет издатель, и что ни одна из сторон не изменила его. Подделка может происходить по проводной связи, между клиентом Docker и реестром, или путем взлома реестра учетной записи владельца, чтобы подменить образ.

Проверка образа Docker
------

Настройки Docker по умолчанию позволяют извлекать образы Docker без проверки их подлинности, что потенциально может привести к использованию образов Docker, происхождение и автор которых не проверены.

Рекомендуется всегда проверять образы перед их использованием, независимо от политики. Чтобы поэкспериментировать с проверкой, временно включите Docker Content Trust с помощью следующей команды:

`export DOCKER_CONTENT_TRUST=1`

Теперь попытайтесь подтянуть образ, про который вы знаете, что он не подписан — запрос будет отклонен, а образ не получен.

Подпись образов Docker
------

Предпочитайте [сертифицированные Docker образы](https://hub.docker.com/search/?certification_status=certified&type=image), полученные от проверенных партнеров, которые были проверены и курированы Docker Hub, вместо образов, происхождение и подлинность которых вы не можете проверить.

Docker позволяет подписывать образы и тем самым обеспечивает еще один уровень защиты. Для подписи образов используйте [Docker Notary](https://docs.docker.com/notary/getting_started/). Notary проверяет подпись образа для вас и блокирует запуск образа, если подпись образа недействительна.

Когда Docker Content Trust включено, как мы показали выше, сборка образа Docker подписывает образ. Когда образ подписывается впервые, Docker создает и сохраняет приватный ключ в ~/docker/trust для вашего пользователя. Затем этот приватный ключ используется для подписи любых дополнительных образов по мере их создания.

Находите, исправляйте и отслеживайте уязвимости в компонентах с открытым исходным кодом
======

Когда мы выбираем базовый образ для нашего Docker контейнера, мы косвенно берем на себя риск всех проблем безопасности, с которыми связан базовый образ. Это могут быть плохо сконфигурированные настройки по умолчанию, которые не способствуют безопасности операционной системы, а также системные библиотеки, которые связаны с выбранным нами базовым образом.

Хорошим первым шагом является использование минимального базового образа, насколько это возможно для запуска приложения без проблем. Это помогает уменьшить пространство для атаки, ограничивая уязвимость; с другой стороны, он не проводит никаких собственных проверок и не защищает вас от будущих уязвимостей, которые могут быть выявлены для используемой версии базового образа.

Поэтому одним из способов защиты от уязвимостей в программном обеспечении с открытым исходным кодом является использование таких инструментов, как Snyk, для добавления непрерывного сканирования и отслеживания уязвимостей, которые могут существовать во всех используемых слоях образов Docker.

Сканирование образа Docker на наличие известных уязвимостей производится с помощью этих команд:

`# fetch the image to be tested so it exists locally
$ docker pull node:10
# scan the image with snyk
$ snyk test --docker node:10 --file=path/to/Dockerfile`

Мониторинг образа Docker на наличие известных уязвимостей, чтобы после обнаружения новых уязвимостей в образе Snyk мог уведомить и предоставить рекомендации по исправлению, производится следующим образом:

`$ snyk monitor --docker node:10`

>На основе сканирования, выполненного пользователями Snyk, мы обнаружили, что 44% сканирований образов Docker выявили известные уязвимости и для которых были доступны более новые и более безопасные базовые образы. Эта консультация по исправлению, в соответствии с которой разработчики могут предпринимать соответствующие действия и обновлять свои образы Docker, уникальна для Snyk.

Snyk также обнаружил, что для 20% всех сканирований образов Docker достаточно только перестроить образ Docker, чтобы [уменьшить количество уязвимостей](https://snyk.io/blog/top-ten-most-popular-docker-images-each-contain-at-least-30-vulnerabilities/). Узнайте больше о количестве открытых отчетов о безопасности 2019 года в блоге Snyk.

Не оставляйте чувствительные данные в образах Docker
======

Иногда при создании приложения внутри образа Docker вам нужны такие секретные данные, как приватный SSH-ключ для извлечения кода из приватного репозитория или токены для установки закрытых пакетов. Если вы копируете их в промежуточный контейнер Docker, они кэшируются в том слое, к которому они были добавлены, даже если вы удалите их позже. Эти токены и ключи должны храниться вне Dockerfile.

Используйте многоэтапные сборки
------

Используя поддержку Docker для многоэтапных сборок, манипулируйте секретами в промежуточном слое образа, который впоследствии удаляется, чтобы никакие чувствительные данные не достигли финальной сборки. Используйте следующий код для добавления секретных данных в промежуточный слой:

`FROM: ubuntu as intermediate

WORKDIR /app
COPY secret/key /tmp/
RUN scp -i /tmp/key build@acme/files .

FROM ubuntu
WORKDIR /app
COPY --from=intermediate /app .`

Используйте команды Docker Secrets
------

Используйте альфа-функцию в Docker для управления секретными данными для монтирования конфиденциальных файлов без их кэширования:

`# syntax = docker/dockerfile:1.0-experimental
FROM alpine

# shows secret from default secret location
RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecre

# shows secret from custom secret location
RUN --mount=type=secret,id=mysecret,dst=/foobar cat /foobar`

Вы можете узнать больше об управлении секретными данными на сайте Docker.

Остерегайтесь рекурсивного копирования
------

Вы также должны обращать внимание на копирование файлов в создаваемый образ. Например, следующая команда рекурсивно копирует всю папку контекста сборки в образ Docker, что может также привести к копированию конфиденциальных файлов:

`COPY . .`

Если в вашей папке есть конфиденциальные файлы, удалите их или используйте .dockerignore, чтобы игнорировать их:

`private.key
appsettings.json`

Используйте фиксированные теги для иммутабельности
======
Каждый образ Docker может иметь несколько тегов, которые представляют варианты одних и тех же образов. Самый распространенный тег — latest, представляющий последнюю версию образа. Теги образов не являются иммутабельными, и автор образов может публиковать один и тот же тег несколько раз.

Это означает, что базовый образ для вашего файла Docker может меняться между сборками. Это может привести к неожиданному поведению из-за изменений, внесенных в базовый образ.

Есть несколько способов устранить эту проблему:

Предпочитайте наиболее конкретный тег из доступных. Если образ имеет несколько тегов, таких как :8 и :8.0.1 или даже :8.0.1-alpine, предпочтите последний, так как он является наиболее конкретной ссылкой на образ. Избегайте использования наиболее общих тегов, например, latest. При закреплении конкретного тега учитывайте, что он может быть в конечном итоге удален.

Чтобы устранить проблему, связанную с тем, что определенный тег образа становится недоступным и становится ограничителем показа для групп, которые полагаются на него, рассмотрите возможность запуска локального зеркала этого образа в реестре или учетной записи, которая находится под вашим собственным контролем. Важно принимать во внимание затраты на обслуживание, необходимые для этого подхода, поскольку это означает, что вам необходимо поддерживать реестр. Хорошей практикой является тиражирование образа, который вы хотите использовать в вашем реестре, чтобы убедиться, что образ, который вы используете, не изменяется.

Будьте предельно конкретны! Вместо того, чтобы подтягивать тег, подтяните образ, используя конкретную SHA256-ссылку на образ Docker, что гарантирует, что вы получите один и тот же образ для каждого запроса. Однако обратите внимание, что использование SHA256-ссылки может имеет следующий риск — если изменится образ, то хэш может больше не работать.

Используйте COPY вместо ADD
======

Docker предоставляет две команды для копирования файлов с хоста в образ Docker при его создании: COPY и ADD. Команды похожи по своей природе, но отличаются по своей функциональности:

COPY — рекурсивно копирует локальные файлы, с указанием исходных и целевых файлов или каталогов. С COPY вы должны объявлять локации.

ADD — рекурсивно копирует локальные файлы, неявно создает каталог назначения, если он не существует, и принимает архивы как локальные или удаленные URL-адреса в качестве источника, который он расширяет или загружает соответственно в каталог назначения.

Хотя различия между ADD и COPY не такие уж фундаментальные, они важны. Помните о них, чтобы избежать потенциальных проблем безопасности:

Когда для загрузки данных непосредственно в исходное местоположение используются удаленные URL-адреса, это может привести к атакам посредника, которые изменяют содержимое загружаемого файла. Кроме того, происхождение и подлинность удаленных URL-адресов должны быть дополнительно проверены. При использовании COPY источник для файлов, которые будут загружены с удаленных URL-адресов, должен быть объявлен через безопасное TLS-соединение, и их происхождение также должно быть проверено.

Замечания о пространстве и слоях образов: использование COPY позволяет отделить добавление архива от удаленных локаций и распаковать его в виде разных слоев, что оптимизирует кэш образов. Если требуются удаленные файлы, объединение их всех в одну команду RUN, которая впоследствии загружает, извлекает и очищает, оптимизируя однослойную операцию на нескольких слоях, которые потребовались бы при использовании ADD.

Когда используются локальные архивы, ADD автоматически извлекает их в каталог назначения. Хотя это может быть приемлемым, это добавляет риск получения zip-бомб и [Zip Slip уязвимостей](https://snyk.io/research/zip-slip-vulnerability), которые затем могут запускаться автоматически.


Используйте метки метаданных
======

Метки образов предоставляют метаданные для образов, которое вы создаете. Это помогает пользователям легче разобраться как использовать образ. Самой распространенной меткой является «maintainer», которая указывает адрес электронной почты и имя человека, поддерживающего этот образ. Добавляйте метаданные с помощью следующей команды LABEL:

`LABEL maintainer="me@acme.com"`

В дополнение к контактам сопровождающего добавляйте любые метаданные, которые важны для вас. Эти метаданные могут содержать: хеш коммита, ссылку на соответствующую сборку, статус качества (все ли тесты пройдены?), исходный код, ссылку на местоположение файла SECURITY.TXT и т. д.

Хорошей практикой является поддержка файла [SECURITY.TXT](https://securitytxt.org/) (RFC5785), который указывает на вашу Responsible Disclosure политику для вашей схемы меток Docker при добавлении новых, например:

`LABEL securitytxt="https://www.example.com/.well-known/security.txt"`

Смотрите [дополнительную информацию](https://label-schema.org/rc1/) о метках для образов Docker.

Используйте многоэтапную сборку для небольших и безопасных образов
======

При создании приложения с помощью Dockerfile создается много артефактов, которые требуются только во время сборки. Это могут быть средства разработки и библиотеки, необходимые для компиляции, или зависимости, необходимые для запуска модульных тестов, временные файлов, секреты и т. д.

Хранение этих артефактов в базовом образе, который может использоваться в продакшене, приводит к увеличению размера образа Docker, что может сильно повлиять на время, потраченное на его загрузку, а также увеличить поверхность атаки, поскольку в результате будет установлено больше пакетов. То же самое верно для образа Docker, который вы используете — вам может понадобиться определенный образ Docker для сборки, но не для запуска кода вашего приложения.

Golang является отличным примером. Чтобы создать приложение Golang, вам нужен компилятор Go. Компилятор создает исполняемый файл, который работает в любой операционной системе, без зависимостей, включая чистые образы.

Это хорошая причина, почему Docker имеет возможность многоэтапной сборки. Эта функция позволяет вам использовать несколько временных образов в процессе сборки, сохраняя только последний образ вместе с информацией, которую вы скопировали в него. Таким образом, у вас есть два образа:

Первый образ — очень большого размера, сопряженный с множеством зависимостей, которые используются для создания приложения и запуска тестов.
Второй образ — очень легкий с точки зрения размера и количества библиотек, содержащий только копии артефактов необходимых для запуска приложения в продакшене.

Используйте линтер
======

Используйте линтер, чтобы избежать распространенных ошибок и установить передовые практические рекомендации, которым инженеры могут следовать в автоматическом режиме.

Одним из таких линтеров является [hadolint](https://github.com/hadolint/hadolint). Он анализирует Dockerfile и выдает предупреждение о любых ошибках, которые не соответствуют его рекомендациям.

Hadolint становится еще более мощным, когда используется в интегрированной среде разработки (IDE). Например, при использовании hadolint в качестве [расширения VSCode](https://marketplace.visualstudio.com/items?itemName=exiasr.hadolint) при вводе появляются ошибки линтинга. Это помогает в написании лучших Dockerfiles быстрее.

[Узнайте больше о защите ваших образов Docker](Узнайте больше о защите ваших образов Docker)
------

_**Прим. перев.**: Тема безопасности Docker, пожалуй, одна из вечных в современном мире IT. Поэтому без лишних объяснений представляем перевод очередной подборки соответствующих рекомендаций. Если вы уже интересовались этим вопросом, многие из них будут вам знакомы. А саму подборку мы дополнили списком из полезных утилит и несколькими ресурсами для дальнейшего изучения вопроса._  

![](https://habrastorage.org/webt/xb/1j/4a/xb1j4a8rv6c7esj64nmp4lsbet4.jpeg)  

Предлагаю вниманию руководство по обеспечению безопасности Docker'а. Обратная связь приветствуется, так как это скорее сборник отрывков с разных ресурсов, и не все они были подвергнуты доскональной проверке. Рекомендации разделены на три категории:  

1.   Необходимые меры внутри операционной системы хоста при работе с Docker'ом;
2.   Инструкции, относящиеся к файлу конфигурации сборки и созданию контейнеров;
3.   Инструменты для безопасности, которые могут интегрироваться со специфическими функциями Docker Enterprise.  

Базой для руководства стали различные ресурсы, многие из которых приведены ниже. Его нельзя назвать исчерпывающим, однако оно охватывает все основы. Дополнительную информацию можно найти в описании к тестам CIS (ссылка приведена в конце этого руководства), а также в документации к Docker'у.  

## Docker Security Benchmark  
[Docker Bench for Security](https://github.com/docker/docker-bench-security) автоматически проверяет ваш Docker на соответствие наиболее распространенным лучшим практикам. Скрипт выступает неплохим эвристическим тестом безопасности, однако его не стоит рассматривать как инструмент комплексного анализа.  

## ОС хоста  

Очевидно, что Docker-контейнер не может быть защищенным, если сама хост-система не защищена. Поэтому необходимо следовать лучшим практикам в области обеспечения безопасности операционных систем. Кроме того, было бы разумно провести анализ уязвимостей в дополнение к следующим рекомендациям.  

### Правила аудита  

Создавайте и используйте правила аудита для файлов, связанных с Docker'ом, с помощью `auditctl`. Например, можно добавить `-w /usr/bin/dockerd -k docker` к `/etc/audit.rules` и перезапустить сервис аудита.  

### Режим FIPS  

Включение режима FIPS заставляет криптографические инструменты переключиться на алгоритмы, внесенные в FIPS _(американские [Federal Information Processing Standards](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards) — прим. перев.)_, соответствуя, таким образом, федеральным и отраслевым нормам и требованиям. Если ОС хоста поддерживает режим FIPS, его можно включить, выполнив следующие команды:  

```bash
sed -i 's/GRUB_CMDLINE_LINUX="/GRUB_CMDLINE_LINUX="fips=1 /g' /etc/default/grub
grub2-mkconfig -o /boot/grub2/grub.cfg && reboot
```

Также необходимо включить FIPS в Docker Engine:  

```bash
mkdir -p /etc/systemd/system/docker.service.d 2>&1; echo -e "[Service]\n Environment=\"DOCKER_FIPS=1\"" > /etc/systemd/system/docker.service.d/fips-module.conf; systemctl daemon-reload; systemctl restart docker
```

Для получения дополнительной информации см. в документации [Docker](https://docs.docker.com/compliance/nist/fips140_2/) и [Red Hat](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-federal_standards_and_regulations).  

### Docker Secrets  

Конфиденциальные данные должны храниться как секреты. Запустить соответствующий сервис можно с помощью команды docker service create:  

```bash
docker service create --label com.docker.ucp.access.label=/prod --name nginx --publish 443 --secret source=orcabank_prod_mobile.ca.pem.v1,target=ca.pem nginx
```

Подробности см. в [документации](https://docs.docker.com/engine/swarm/secrets/).  

### Файл конфигурации Docker'а  

Следующие настройки можно добавить в файл конфигурации `/etc/docker/daemon.json`:  

* `"icc":false` — отключает обмен данными между контейнерами, чтобы избежать ненужной утечки информации.
* `log-level: "info"` — захватывает все логи кроме отладочных.
* ```plaintext
    {
      "log-driver": "syslog",
      "log-opts": {
        "syslog-address": "udp://1.2.3.4:1111"
      }
    }
    ```

    — подключает удаленное ведение логов, пересылает их по указанному адресу. Работает только в том случае, если запущен демон syslog. В качестве опций принимаются TCP и UDP. Также возможно подключение для каждого конкретного контейнера. Для этого устанавливается специальный флаг при запуске Docker'а (`--log-opt syslog-address=ADDRESS`).

* `"userns-remap": "Your_User"` — предотвращает поднятие привилегий (privilege escalation), изолируя пространство имен под конкретного пользователя.  

### Безопасность транспортного уровня  

Возможность подключения к демону Docker'а (если удаленный доступ необходим) должна быть только у пользователей с доступом к учетным данным TLS-клиента.  

### Плагины авторизации  

Определитесь с тем, каким пользователям какие команды разрешено выполнять, и создайте соответствующий плагин авторизации для Docker'а. Затем запустите демон Docker'а и добавьте в него плагин:  

```bash
dockerd --authorization-plugin=PLUGIN_ID
```

Чтобы больше узнать о создании авторизационных плагинов, см. в [документации](https://docs.docker.com/engine/extend/plugins_authorization/).  

### Параметры демона  

Демон Docker'а работает с набором параметров по умолчанию.  

* `--live-restore` — этот параметр помогает сократить время простоя контейнеров при выключении или перезагрузке системы. Становится проще их патчить или обновлять с минимальным простоем;
* `--userland-proxy=false` — когда доступны или используются hairpin NAT'ы, прокси в пользовательском пространстве становится избыточной службой, которая только увеличивает число возможных векторов атаки;
* `--no-new-privileges` — предотвращает получение дополнительных привилегий контейнерами при помощи suid или sguid;
* `--seccomp-profile /path/to/profile` — если у вас есть собственный профиль seccomp, можно его применить с помощью этого флага. Узнать больше о Seccomp и Docker можно [здесь](https://docs.docker.com/engine/security/seccomp/).  

## Конфигурация контейнеров и файлов сборки  

### Создание пользователя  

Убедитесь, что для контейнера создан пользователь и запускайте его под этим пользователем (НЕ запускайте контейнер под рутом).  

### Удаленный доступ  

Запретите удаленный доступ к демону. Если он все же необходим, защитите его сертификатами.  

### Изолируйте пространство имен пользователя  

Особенно важно убедиться, что пространство имен пользователя в Docker'е изолировано, поскольку по умолчанию оно используется совместно с пространством имен хоста. В некоторых случаях этим можно воспользоваться для поднятия привилегий или даже для выхода за пределы контейнера. Изолировать пользовательское пространство имен можно путем редактирования файла конфигурации (как описывается выше в разделе «Файл конфигурации Docker'а»). Дополнительное упоминание этой проблемы здесь вызвано ее важностью.  

### Healthcheck'и  

Healthcheck (проверка работоспособности) — мощный инструмент, позволяющий проверять целостность контейнера. Настраивается он в Dockerfile с помощью инструкции `HEALTHCHECK`. Healthcheck'и позволяют убедиться, что контейнер работает должным образом. В приведенном ниже примере проверка работоспособности завершается 0, если сервер работает, и 1, если он «упал»:  

```bash
HEALTHCHECK CMD curl --fail http://localhost || exit 1
```

### SELinux  

Если SELinux поддерживается операционной системой хоста, создайте или импортируйте политику SELinux и запускайте Docker в режиме демона с включенным SELinux:  

```bash
docker daemon --selinux-enable
```

В этом случае Docker-контейнеры можно запускать с параметрами безопасности, например:  

```bash
docker run --interactive --tty --security-opt label=level:TopSecret centos /bin/bash
```

### Сетевые интерфейсы  

По умолчанию Docker слушает все сетевые интерфейсы. Поскольку в большинстве случаев трафик ожидается только на одном из них, подобный подход неоправданно повышает риск атаки. Поэтому при запуске контейнера можно привязать его порты к конкретным интерфейсам на хосте:  

```bash
docker run --detach --publish 10.2.3.4:49153:80 nginx
```

### Кэшированные версии образов  

При скачивании образов убедитесь, что локальный кэш соответствует содержимому репозитория. В противном случае вы можете получить устаревшую версию образа или образ, содержащий уязвимости.  

### Сетевой мост  

Сетевая модель по умолчанию, `docker0`, уязвима перед атаками типа ARP-spoofing и MAC-flooding. Чтобы решить эту проблему, создайте сетевой мост в соответствии со своими спецификациями, как описано [здесь](https://docs.docker.com/network/bridge/).  

### Предупреждение о сокете Docker'а  

Никогда не пробрасывайте сокет Docker'а внутрь контейнера. Иначе у контейнера появится возможность выполнять команды Docker'а и, следовательно, связываться с операционной системой хоста и контролировать её. Не делайте этого.  

## Конфигурирование Docker Enterprise  

### Docker Trust  

Docker Trust позволяет генерировать ключи, с помощью которых можно проверять криптографическую целостность образов. Ключи Docker Trust можно использовать для подписи образов Docker приватными ключами, что проверяются публичными ключами на Notary Server. Дополнительная информация — [здесь](https://docs.docker.com/engine/security/trust/content_trust/). Включение Docker Trust в Enterprise Engine подробно описано в [этом разделе документации](https://docs.docker.com/engine/security/trust/content_trust/#enabling-dct-within-the-docker-enterprise-engine).  

### Сканирование уязвимостей  

В Docker Enterprise имеется встроенный сканер уязвимостей, дающий возможность загрузить базу CVE для offline-сканирования уязвимостей в образах. Регулярное сканирование образов помогает сделать их более безопасными: пользователь сразу получает предупреждения о найденных уязвимостях. Подробнее о том, как это можно сделать, см. [здесь](https://docs.docker.com/ee/dtr/user/manage-images/scan-images-for-vulnerabilities/).  

_**Прим. перев.**: Существуют и Open Source-сканеры уязвимостей в Docker-образах, примеры которых см. в конце материала._  

### Интеграция LDAP и UCP  

Universal Control Plane можно интегрировать с LDAP. Результатом станет упрощенная система аутентификации, позволяющая избежать ненужного дублирования. Подробнее об этом можно почитать в статье [Integrate with an LDAP directory](https://docs.docker.com/ee/ucp/admin/configure/external-auth/).  

## Другие материалы  

Дополнительную информацию о лучших практиках в области обеспечения безопасности Docker'а можно найти на [docs.docker.com](http://docs.docker.com/). Также рекомендуем загрузить [тесты Center for Internet Security для Docker](https://learn.cisecurity.org/benchmarks).  

## Бонус от переводчика  

В качестве логичного дополнения к этой статье публикуем список из **10 популярных Open Source-утилит для обеспечения безопасности в Docker**. Он был заимствован из [другой статьи](https://techbeacon.com/security/10-top-open-source-tools-docker-security) (за авторством Bill Doerrfeld из Doerrfeld.io).  

_**NB**: Подробнее о многих из упомянутых здесь проектах читайте также в статье «[33+ инструмента для безопасности Kubernetes](https://habr.com/ru/company/flant/blog/465141/)»._  

1.  [**Docker Bench for Security**](https://github.com/docker/docker-bench-security) — уже упомянутый в самом начале статьи скрипт, проверяющий контейнеры Docker на соответствие распространённым практикам обеспечения безопасности.  

    ![](https://habrastorage.org/webt/yj/gu/cg/yjgucgupdvarz3kbawcwzqt-k_g.png)
2.  [**Clair**](https://coreos.com/clair/docs/latest/) — наверное, самая популярная утилита для статического анализа уязвимостей в контейнере. Использует для этого многочисленные базы уязвимостей CVE (включая трекеры ведущих Linux-дистрибутивов, таких как Red Hat, Debian, Ubuntu). Предлагает API для разработчиков и простую возможность по расширению функций (через добавление «драйверов»). Применяется в популярном публичном реестре образов контейнере (аналоге Docker Hub) — Quay.io.
3.  [**Cilium**](https://github.com/cilium/cilium) — решение для обеспечения сетевой безопасности на уровне ядра, основанное на технологии фильтрации сетевых пакетов BPF.
4.  [**Anchore**](https://github.com/anchore/anchore-engine) — утилита для анализа содержимого образов на наличие уязвимостей в безопасности по базе CVE. Кроме того, она позволяет применять пользовательские политики (на основе разных данных включая белые/черные списки, содержимое файлов и т.п.) для оценки безопасности контейнеров.
5.  [**OpenSCAP Workbench**](https://www.open-scap.org/) — целая экосистема для создания и поддержания политик безопасности на разных платформах. Для проверки контейнеров предлагает утилиту `oscap-docker`.
6.  [**Dagda**](https://github.com/eliasgranderubio/dagda) — утилита для сканирования Docker-контейнеров на наличие уязвимостей, троянов, вирусов и malware. В базы CVE включены проверки по зависимостям от OWASP, база Red Hat Oval, репозиторий эксплоитов Exploit Database.
7.  [**Notary**](http://github.com/theupdateframework/notary) — фреймворк для подписывания Docker-образов, изначально созданный в Docker Inc (и затем переданный на развитие в CNCF). Его использование позволяет делегировать роли и распределять ответственности по конетйнерам, а также верифицировать криптографическую целостность образов.
8.  [**Grafaes**](http://grafeas.io/) — API для метаданных, призванный предназначенный для управления внутренними политиками безопасности. Как пример, он позволяет улучшить работу сканеров безопасности контейнеров. Shopify использует этот API для управления метаданными по своим 500 тысячам образов.
9.  [**Sysdig Falco**](https://github.com/draios/falco/) — утилита для Kubernetes, следящая за поведением системы: активностью в контейнерах, на хостах, в сети. Позволяет настраивать непрерывные проверки в инфраструктуре, обнаружение аномалий и отправку алертов по любым системным вызовам Linux.
10.  [**Banyanops Collector**](https://github.com/banyanops/collector) — ещё один инструмент для статического анализа образов Docker-контейнеров. Позволяет «заглядывать» в файлы образа, собирая необходимые данные, применяя нужные политики и т.п.  
**Ещё одну хорошую подборку практических рекомендаций** по тому, как сделать Docker безопаснее, можно найти в [этой статье](https://blog.aquasec.com/docker-security-best-practices) компании Aqua Security. Многие её советы пересекаются с уже упомянутыми выше, но есть и другие. Например, авторы предлагают организовать мониторинг активности в контейнерах и указывают, на что обратить внимание при использовании Docker Swarm.  

Для желающих ещё детальнее погрузиться в эту тему в прошлом году вышла **книга «[Docker Security: Quick Reference](https://binarymist.io/publication/docker-security/)»**, фрагменты которой свободно доступны [здесь](https://binarymist.io/blog/2018/03/31/docker-security/).  

Наконец, для практического знакомства с некоторыми аспектами безопасности Docker: профилями Seccomp и использованием capabilities Linux-ядра в контейнерах — можно пройти соответствующие **лабораторные работы на [ресурсе Play with Docker](https://training.play-with-docker.com/ops-stage2/)**\* — см. секцию «Security».  

![](https://habrastorage.org/webt/ov/up/d2/ovupd25unjsv6tgr3ynrosucxc4.png)  

_\* Про сам этот ресурс мы [рассказывали](https://habr.com/ru/company/flant/blog/334470/) два года назад, а в ноябре 2018-го с ним случилась очень занимательная (с точки зрения безопасности) история. Если вкратце, то специалистам из CyberArk Software Ltd. удалось его взломать: добиться возможности выполнять команды за пределами контейнеров, т.е. на хост-системе. Прекрасная иллюстрация проблемы безопасности в Docker, не так ли? Обо всех деталях случившегося читайте [здесь](https://www.cyberark.com/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host/)._
