---
title: '10 практических рекомендаций по безопасности образов Docker.'
date: 2020-01-11
permalink: /posts/2020/01/blog-post-2/
tags:
  - cool posts
  - category1
  - category2
---

Эта статья советов и рекомендаций, которые обеспечивают более безопасный и качественный процесс обработки образов Docker.
[Оригинал - part1](https://habr.com/ru/company/otus/blog/480970/)
[Оригинал - part2](https://habr.com/ru/company/otus/blog/482044/)

Предпочитайте минимальные базовые образы
======
Зачастую вы можете начинать проекты с базового образа контейнера Docker, например, с написания Dockerfile с FROM node «по умолчанию». Однако при указании образа node следует учитывать, что полностью установленный дистрибутив Debian Stretch является базовым образом, который используется для его сборки. Если ваш проект не требует каких-либо общих системных библиотек или утилит, то лучше избегать использования полнофункциональной операционной системы (ОС) в качестве базового образа.

Многие популярные контейнеры Docker, представленные на веб-сайте Docker Hub, содержат в себе образы, содержащие много известных уязвимостей. Например, когда вы используете популярный универсальный образ docker pull node вы фактически вводите в свое приложение ОС, которая, как известно, имеет 580 уязвимостей в своих системных библиотеках.
[УЗНАЙТЕ БОЛЬШЕ О БЕЗОПАСНОСТИ ВАШИХ ОБРАЗОВ](https://snyk.io/container-vulnerability-management/)

Наименее привилегированный пользователь
======
Когда Dockerfile не указывает USER, по умолчанию контейнер выполняется с использованием root-пользователя. На практике существует очень мало причин, по которым контейнер должен иметь root-привилегии. Docker по умолчанию запускает контейнеры, используя root-пользователя. Затем когда это пространство имен сопоставляется с root-пользователем в работающем контейнере, из этого следует, что контейнер потенциально имеет root-доступ на хосте Docker. Запуск приложения в контейнере с root-пользователем еще больше расширяет пространство для атаки и обеспечивает легкий путь к повышению привилегий, если само приложение уязвимо для эксплойтов.

Чтобы минимизировать незащищенность, включите создание специально выделенного пользователя и группу в образе Docker для приложения; используйте директиву USER в Dockerfile, чтобы убедиться, что контейнер запускает приложение с наименее привилегированным доступом.

Выделенный пользователь может не существовать в образе; создайте этого пользователя, используя инструкции в Dockerfile.

Ниже приведен полный пример того, как это сделать для универсального образа Ubuntu:

`ROM ubuntu
RUN mkdir /app
RUN groupadd -r lirantal && useradd -r -s /bin/false -g lirantal lirantal
WORKDIR /app
COPY . /app
RUN chown -R lirantal:lirantal /app
USER lirantal
CMD node index.js`

Пример выше:

создает системного пользователя (-r) без пароля, без установки домашнего каталога и без оболочки
добавляет пользователя, которого мы создали, к существующей группе, которую мы создали заранее (используя groupadd)
добавляет последний аргумент к имени пользователя, которого мы хотим создать, в сочетании с группой, которую мы создали

Node.js и образов alpine, они уже включают в себя универсального пользователя, называемого node. Вот пример Node.js, использующий универсального пользователя node:

`FROM node:10-alpine 
RUN mkdir /app
COPY . /app
RUN chown -R node:node /app
USER node
CMD [“node”, “index.js”]`


Подписывайте и проверяйте образы, чтобы избегать MITM атаки
======

Аутентичность образов Docker является проблемой. Мы полагаемся на эти образы, поскольку буквально используем их в качестве контейнера, который запускает наш код в продакшене. Поэтому важно убедиться, что образ, который мы используем, является именно тем, который поставляет издатель, и что ни одна из сторон не изменила его. Подделка может происходить по проводной связи, между клиентом Docker и реестром, или путем взлома реестра учетной записи владельца, чтобы подменить образ.

Проверка образа Docker
------

Настройки Docker по умолчанию позволяют извлекать образы Docker без проверки их подлинности, что потенциально может привести к использованию образов Docker, происхождение и автор которых не проверены.

Рекомендуется всегда проверять образы перед их использованием, независимо от политики. Чтобы поэкспериментировать с проверкой, временно включите Docker Content Trust с помощью следующей команды:

`export DOCKER_CONTENT_TRUST=1`

Теперь попытайтесь подтянуть образ, про который вы знаете, что он не подписан — запрос будет отклонен, а образ не получен.

Подпись образов Docker
------

Предпочитайте [сертифицированные Docker образы](https://hub.docker.com/search/?certification_status=certified&type=image), полученные от проверенных партнеров, которые были проверены и курированы Docker Hub, вместо образов, происхождение и подлинность которых вы не можете проверить.

Docker позволяет подписывать образы и тем самым обеспечивает еще один уровень защиты. Для подписи образов используйте [Docker Notary](https://docs.docker.com/notary/getting_started/). Notary проверяет подпись образа для вас и блокирует запуск образа, если подпись образа недействительна.

Когда Docker Content Trust включено, как мы показали выше, сборка образа Docker подписывает образ. Когда образ подписывается впервые, Docker создает и сохраняет приватный ключ в ~/docker/trust для вашего пользователя. Затем этот приватный ключ используется для подписи любых дополнительных образов по мере их создания.

Находите, исправляйте и отслеживайте уязвимости в компонентах с открытым исходным кодом
======

Когда мы выбираем базовый образ для нашего Docker контейнера, мы косвенно берем на себя риск всех проблем безопасности, с которыми связан базовый образ. Это могут быть плохо сконфигурированные настройки по умолчанию, которые не способствуют безопасности операционной системы, а также системные библиотеки, которые связаны с выбранным нами базовым образом.

Хорошим первым шагом является использование минимального базового образа, насколько это возможно для запуска приложения без проблем. Это помогает уменьшить пространство для атаки, ограничивая уязвимость; с другой стороны, он не проводит никаких собственных проверок и не защищает вас от будущих уязвимостей, которые могут быть выявлены для используемой версии базового образа.

Поэтому одним из способов защиты от уязвимостей в программном обеспечении с открытым исходным кодом является использование таких инструментов, как Snyk, для добавления непрерывного сканирования и отслеживания уязвимостей, которые могут существовать во всех используемых слоях образов Docker.

Сканирование образа Docker на наличие известных уязвимостей производится с помощью этих команд:

`# fetch the image to be tested so it exists locally
$ docker pull node:10
# scan the image with snyk
$ snyk test --docker node:10 --file=path/to/Dockerfile`

Мониторинг образа Docker на наличие известных уязвимостей, чтобы после обнаружения новых уязвимостей в образе Snyk мог уведомить и предоставить рекомендации по исправлению, производится следующим образом:

`$ snyk monitor --docker node:10`

>На основе сканирования, выполненного пользователями Snyk, мы обнаружили, что 44% сканирований образов Docker выявили известные уязвимости и для которых были доступны более новые и более безопасные базовые образы. Эта консультация по исправлению, в соответствии с которой разработчики могут предпринимать соответствующие действия и обновлять свои образы Docker, уникальна для Snyk.

Snyk также обнаружил, что для 20% всех сканирований образов Docker достаточно только перестроить образ Docker, чтобы [уменьшить количество уязвимостей](https://snyk.io/blog/top-ten-most-popular-docker-images-each-contain-at-least-30-vulnerabilities/). Узнайте больше о количестве открытых отчетов о безопасности 2019 года в блоге Snyk.

Не оставляйте чувствительные данные в образах Docker
======

Иногда при создании приложения внутри образа Docker вам нужны такие секретные данные, как приватный SSH-ключ для извлечения кода из приватного репозитория или токены для установки закрытых пакетов. Если вы копируете их в промежуточный контейнер Docker, они кэшируются в том слое, к которому они были добавлены, даже если вы удалите их позже. Эти токены и ключи должны храниться вне Dockerfile.

Используйте многоэтапные сборки
------

Используя поддержку Docker для многоэтапных сборок, манипулируйте секретами в промежуточном слое образа, который впоследствии удаляется, чтобы никакие чувствительные данные не достигли финальной сборки. Используйте следующий код для добавления секретных данных в промежуточный слой:

`FROM: ubuntu as intermediate

WORKDIR /app
COPY secret/key /tmp/
RUN scp -i /tmp/key build@acme/files .

FROM ubuntu
WORKDIR /app
COPY --from=intermediate /app .`

Используйте команды Docker Secrets
------

Используйте альфа-функцию в Docker для управления секретными данными для монтирования конфиденциальных файлов без их кэширования:

`# syntax = docker/dockerfile:1.0-experimental
FROM alpine

# shows secret from default secret location
RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecre

# shows secret from custom secret location
RUN --mount=type=secret,id=mysecret,dst=/foobar cat /foobar`

Вы можете узнать больше об управлении секретными данными на сайте Docker.

Остерегайтесь рекурсивного копирования
------

Вы также должны обращать внимание на копирование файлов в создаваемый образ. Например, следующая команда рекурсивно копирует всю папку контекста сборки в образ Docker, что может также привести к копированию конфиденциальных файлов:

`COPY . .`

Если в вашей папке есть конфиденциальные файлы, удалите их или используйте .dockerignore, чтобы игнорировать их:

`private.key
appsettings.json`

Используйте фиксированные теги для иммутабельности
======
Каждый образ Docker может иметь несколько тегов, которые представляют варианты одних и тех же образов. Самый распространенный тег — latest, представляющий последнюю версию образа. Теги образов не являются иммутабельными, и автор образов может публиковать один и тот же тег несколько раз.

Это означает, что базовый образ для вашего файла Docker может меняться между сборками. Это может привести к неожиданному поведению из-за изменений, внесенных в базовый образ.

Есть несколько способов устранить эту проблему:

Предпочитайте наиболее конкретный тег из доступных. Если образ имеет несколько тегов, таких как :8 и :8.0.1 или даже :8.0.1-alpine, предпочтите последний, так как он является наиболее конкретной ссылкой на образ. Избегайте использования наиболее общих тегов, например, latest. При закреплении конкретного тега учитывайте, что он может быть в конечном итоге удален.

Чтобы устранить проблему, связанную с тем, что определенный тег образа становится недоступным и становится ограничителем показа для групп, которые полагаются на него, рассмотрите возможность запуска локального зеркала этого образа в реестре или учетной записи, которая находится под вашим собственным контролем. Важно принимать во внимание затраты на обслуживание, необходимые для этого подхода, поскольку это означает, что вам необходимо поддерживать реестр. Хорошей практикой является тиражирование образа, который вы хотите использовать в вашем реестре, чтобы убедиться, что образ, который вы используете, не изменяется.

Будьте предельно конкретны! Вместо того, чтобы подтягивать тег, подтяните образ, используя конкретную SHA256-ссылку на образ Docker, что гарантирует, что вы получите один и тот же образ для каждого запроса. Однако обратите внимание, что использование SHA256-ссылки может имеет следующий риск — если изменится образ, то хэш может больше не работать.

Используйте COPY вместо ADD
======

Docker предоставляет две команды для копирования файлов с хоста в образ Docker при его создании: COPY и ADD. Команды похожи по своей природе, но отличаются по своей функциональности:

COPY — рекурсивно копирует локальные файлы, с указанием исходных и целевых файлов или каталогов. С COPY вы должны объявлять локации.

ADD — рекурсивно копирует локальные файлы, неявно создает каталог назначения, если он не существует, и принимает архивы как локальные или удаленные URL-адреса в качестве источника, который он расширяет или загружает соответственно в каталог назначения.

Хотя различия между ADD и COPY не такие уж фундаментальные, они важны. Помните о них, чтобы избежать потенциальных проблем безопасности:

Когда для загрузки данных непосредственно в исходное местоположение используются удаленные URL-адреса, это может привести к атакам посредника, которые изменяют содержимое загружаемого файла. Кроме того, происхождение и подлинность удаленных URL-адресов должны быть дополнительно проверены. При использовании COPY источник для файлов, которые будут загружены с удаленных URL-адресов, должен быть объявлен через безопасное TLS-соединение, и их происхождение также должно быть проверено.

Замечания о пространстве и слоях образов: использование COPY позволяет отделить добавление архива от удаленных локаций и распаковать его в виде разных слоев, что оптимизирует кэш образов. Если требуются удаленные файлы, объединение их всех в одну команду RUN, которая впоследствии загружает, извлекает и очищает, оптимизируя однослойную операцию на нескольких слоях, которые потребовались бы при использовании ADD.

Когда используются локальные архивы, ADD автоматически извлекает их в каталог назначения. Хотя это может быть приемлемым, это добавляет риск получения zip-бомб и [Zip Slip уязвимостей](https://snyk.io/research/zip-slip-vulnerability), которые затем могут запускаться автоматически.


Используйте метки метаданных
======

Метки образов предоставляют метаданные для образов, которое вы создаете. Это помогает пользователям легче разобраться как использовать образ. Самой распространенной меткой является «maintainer», которая указывает адрес электронной почты и имя человека, поддерживающего этот образ. Добавляйте метаданные с помощью следующей команды LABEL:

`LABEL maintainer="me@acme.com"`

В дополнение к контактам сопровождающего добавляйте любые метаданные, которые важны для вас. Эти метаданные могут содержать: хеш коммита, ссылку на соответствующую сборку, статус качества (все ли тесты пройдены?), исходный код, ссылку на местоположение файла SECURITY.TXT и т. д.

Хорошей практикой является поддержка файла [SECURITY.TXT](https://securitytxt.org/) (RFC5785), который указывает на вашу Responsible Disclosure политику для вашей схемы меток Docker при добавлении новых, например:

`LABEL securitytxt="https://www.example.com/.well-known/security.txt"`

Смотрите [дополнительную информацию](https://label-schema.org/rc1/) о метках для образов Docker.

Используйте многоэтапную сборку для небольших и безопасных образов
======

При создании приложения с помощью Dockerfile создается много артефактов, которые требуются только во время сборки. Это могут быть средства разработки и библиотеки, необходимые для компиляции, или зависимости, необходимые для запуска модульных тестов, временные файлов, секреты и т. д.

Хранение этих артефактов в базовом образе, который может использоваться в продакшене, приводит к увеличению размера образа Docker, что может сильно повлиять на время, потраченное на его загрузку, а также увеличить поверхность атаки, поскольку в результате будет установлено больше пакетов. То же самое верно для образа Docker, который вы используете — вам может понадобиться определенный образ Docker для сборки, но не для запуска кода вашего приложения.

Golang является отличным примером. Чтобы создать приложение Golang, вам нужен компилятор Go. Компилятор создает исполняемый файл, который работает в любой операционной системе, без зависимостей, включая чистые образы.

Это хорошая причина, почему Docker имеет возможность многоэтапной сборки. Эта функция позволяет вам использовать несколько временных образов в процессе сборки, сохраняя только последний образ вместе с информацией, которую вы скопировали в него. Таким образом, у вас есть два образа:

Первый образ — очень большого размера, сопряженный с множеством зависимостей, которые используются для создания приложения и запуска тестов.
Второй образ — очень легкий с точки зрения размера и количества библиотек, содержащий только копии артефактов необходимых для запуска приложения в продакшене.

Используйте линтер
======

Используйте линтер, чтобы избежать распространенных ошибок и установить передовые практические рекомендации, которым инженеры могут следовать в автоматическом режиме.

Одним из таких линтеров является [hadolint](https://github.com/hadolint/hadolint). Он анализирует Dockerfile и выдает предупреждение о любых ошибках, которые не соответствуют его рекомендациям.

Hadolint становится еще более мощным, когда используется в интегрированной среде разработки (IDE). Например, при использовании hadolint в качестве [расширения VSCode](https://marketplace.visualstudio.com/items?itemName=exiasr.hadolint) при вводе появляются ошибки линтинга. Это помогает в написании лучших Dockerfiles быстрее.

[Узнайте больше о защите ваших образов Docker](Узнайте больше о защите ваших образов Docker)
------
